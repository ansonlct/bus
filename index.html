<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS Web App Ë®≠ÂÆö -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Â∑¥Â£´Áè≠Ê¨°">

    <!-- iOS ‰∏ªÁï´Èù¢ÂúñÁ§∫ (Âè™Áî®ÈÄôÂºµÂúñ) -->
    <link rel="apple-touch-icon" sizes="180x180" href="bus-logo.jpg">

    <!-- ÁÄèË¶ΩÂô®ÂàÜÈ†Å/ÂÖ∂‰ªñÂúñÁ§∫ (ÁπºÁ∫åÁî® Emoji) -->
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüöå%3C/text%3E%3C/svg%3E">

    <title>È¶ôÊ∏ØÂ∑¥Â£´Áè≠Ê¨°Êü•Ë©¢</title>
    <style>
        :root {
            --bg-color: #F2F2F7;
            --card-bg: #FFFFFF;
            --text-main: #1C1C1E;
            --text-sub: #8E8E93;
            --kmb-red: #E3001B;
            --ctb-yellow: #F9D300;
            --accent: #007AFF;
            --separator: #E5E5EA;
            --sidebar-width: 280px;
        }

        body.dark-mode {
            --bg-color: #000000;
            --card-bg: #1C1C1E;
            --text-main: #FFFFFF;
            --text-sub: #98989D;
            --separator: #38383A;
            --ctb-yellow: #D1B100; /* Darker yellow for dark mode */
        }

        * { -webkit-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        select, input, textarea { -webkit-user-select: auto; user-select: auto; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0; padding: env(safe-area-inset-top) 0 0 0;
            color: var(--text-main);
            height: 100dvh; display: flex; flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden;
        }

        .container { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: 600px; margin: 0 auto; overflow: hidden; position: relative; z-index: 1; }

        /* --- È†ÇÈÉ®Â∞éËà™ÂçÄ --- */
        .search-area {
            padding: 12px 16px;
            background: var(--bg-color);
            display: flex; gap: 8px;
            z-index: 200;
            box-shadow: 0 1px 0 rgba(0,0,0,0.05);
            align-items: center;
        }

        .menu-btn {
            font-size: 1.5rem; padding: 4px 8px; cursor: pointer; color: var(--text-main);
        }

        .search-wrapper { position: relative; flex: 1; }

        .search-input {
            width: 100%; padding: 10px 32px 10px 14px;
            border-radius: 12px; border: none;
            background: var(--card-bg); color: var(--text-main); font-size: 1.1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); outline: none;
            transition: border 0.2s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px); }
            40%, 80% { transform: translateX(6px); }
        }
        .search-input.shake {
            animation: shake 0.4s ease-in-out;
            border: 1px solid #FF3B30 !important;
        }
        
        .clear-input-btn {
            position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
            width: 20px; height: 20px; border-radius: 50%;
            background: rgba(142, 142, 147, 0.3); color: white;
            font-size: 12px; display: none;
            align-items: center; justify-content: center; cursor: pointer;
        }
        .clear-input-btn:active { background: rgba(142, 142, 147, 0.8); }

        .suggestions-list {
            position: absolute; top: 110%; left: 0; right: 0;
            background: var(--card-bg); border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            max-height: 300px; overflow-y: auto; overflow-x: hidden;
            transition: max-height 0.2s ease-out; z-index: 1000;
            display: none;
        }
        .suggestions-list.show { display: block; border: 1px solid rgba(0,0,0,0.05); }

        .suggestion-item {
            padding: 12px 16px; border-bottom: 1px solid var(--separator);
            font-size: 1.05rem; color: var(--text-main); cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
        }
        .suggestion-item:active { background: rgba(0,0,0,0.05); }
        .suggestion-item:last-child { border-bottom: none; }
        
        .sug-left { display: flex; align-items: center; gap: 8px; }
        .sug-route { font-weight: 700; font-size: 1.1rem; }
        .sug-desc { font-size: 0.8rem; color: var(--text-sub); flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: right; }

        .co-badge {
            font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; color: white; font-weight: bold; width: 40px; text-align: center;
        }
        .badge-kmb { background: var(--kmb-red); }
        .badge-ctb { 
            background: var(--ctb-yellow); 
            color: white; /* Changed to white */
            text-shadow: 0 0 2px rgba(0,0,0,0.3); /* Added shadow for readability on yellow */
        }

        .search-btn {
            padding: 0 16px; background: var(--accent); color: white;
            border: none; border-radius: 12px; font-weight: 600; font-size: 1rem;
            cursor: pointer; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
            transition: opacity 0.2s; white-space: nowrap; height: 42px;
        }
        .search-btn:active { transform: scale(0.96); opacity: 0.9; }

        .content-scroll { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding: 10px 16px; scroll-behavior: smooth; display: flex; flex-direction: column;}

        /* --- Âç°ÁâáÊ®£Âºè --- */
        .card {
            background: var(--card-bg); border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); overflow: hidden;
            border: 1px solid rgba(0,0,0,0.05); margin-bottom: 20px;
            position: relative;
            animation: slideIn 0.3s ease-out;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            flex-shrink: 0;
        }
        .card.dragging {
            opacity: 0.5; background: #f8f8f8; box-shadow: 0 10px 20px rgba(0,0,0,0.2); z-index: 100;
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card-header {
            /* Default KMB Style */
            background: linear-gradient(135deg, #E3001B, #C20017);
            padding: 12px 16px; color: white;
            display: flex; flex-direction: column; gap: 8px;
            position: relative; padding-left: 40px;
        }
        
        /* Citybus Specific Styles - White Text Version */
        .ctb-card .card-header {
            background: linear-gradient(135deg, var(--ctb-yellow), #E6C100);
            color: white; /* Changed from blue to white */
        }
        /* Overrides to ensure white icons/text */
        .ctb-card .close-card-btn { background: rgba(0, 0, 0, 0.1); color: white; }
        .ctb-card .close-card-btn:active { background: rgba(0, 0, 0, 0.2); }
        .ctb-card .drag-handle { color: rgba(255, 255, 255, 0.6); }
        .ctb-card .dir-opt { color: rgba(255, 255, 255, 0.7); }
        
        /* Active Tab for Citybus */
        .ctb-card .dir-opt.active { 
            background: white; 
            color: #C2A000; /* Dark Gold/Yellow text to avoid blue but keep brand feel */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }

        .drag-handle {
            position: absolute; top: 12px; left: 10px; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; color: rgba(255, 255, 255, 0.6); cursor: grab; z-index: 15;
            touch-action: none;
        }
        
        .close-card-btn {
            position: absolute; top: 10px; right: 10px;
            width: 28px; height: 28px;
            background: rgba(0, 0, 0, 0.2); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: white; font-weight: bold; font-size: 14px;
            backdrop-filter: blur(4px); transition: background 0.2s; z-index: 10;
        }
        .close-card-btn:active { background: rgba(0, 0, 0, 0.4); }

        .header-top { display: flex; align-items: center; padding-right: 40px; }
        .icon { font-size: 1.4rem; margin-right: 8px; }
        .card-title { font-size: 1.3rem; font-weight: 800; text-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        
        .direction-switch {
            display: flex; background: rgba(0, 0, 0, 0.1);
            padding: 3px; border-radius: 8px; margin-top: 4px;
        }
        
        .dir-opt {
            flex: 1; text-align: center;
            font-size: 0.85rem; color: rgba(255, 255, 255, 0.7);
            padding: 6px 4px; border-radius: 6px;
            cursor: pointer; transition: all 0.2s; font-weight: 500;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .dir-opt.active {
            background: white; color: var(--kmb-red); font-weight: 700; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .card-content { padding: 4px 16px 16px; min-height: 50px; }

        .schedule-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 14px 0; border-bottom: 1px dashed var(--separator);
            cursor: pointer; overflow: hidden;
            max-height: 100px; opacity: 1;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 0.3s ease-in-out, padding 0.4s ease, margin 0.4s ease, border-bottom-width 0.4s ease;
        }
        .schedule-item:active { background-color: rgba(0,0,0,0.03); }
        .schedule-item:last-child { border-bottom: none; }
        .schedule-item.no-border { border-bottom: none !important; }
        .schedule-item.hidden-row {
            max-height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; margin: 0; border-bottom-width: 0; pointer-events: none;
        }

        .stop-info { flex: 1; display: flex; align-items: center; overflow: hidden; padding-right: 10px; }
        .dest-name { font-size: 1.05rem; font-weight: 600; color: var(--text-main); }
        .dest-seq { 
            color: var(--text-sub); font-size: 0.8rem; margin-right: 10px; font-weight: 400; 
            display: inline-block; width: 30px; text-align: center;
            cursor: pointer; flex-shrink: 0; user-select: none; transition: transform 0.2s; 
        }
        .eta-time { font-size: 0.85rem; color: var(--text-sub); display: block; text-align: right; margin-bottom: 2px;}
        .eta-minutes {
            font-size: 1rem; color: #34C759; font-weight: 700;
            background: #E8F5E9; padding: 4px 8px; border-radius: 6px;
            display: inline-block; min-width: 45px; text-align: center; transition: all 0.2s;
        }
        body.dark-mode .eta-minutes { background: rgba(52, 199, 89, 0.2); color: #32D74B; }
        .urgent { color: #FF3B30 !important; background: #FFEBEE !important; }
        body.dark-mode .urgent { background: rgba(255, 69, 58, 0.2) !important; color: #FF453A !important; }
        .eta-minutes.show-real-time {
            font-family: "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
            font-weight: 600; background: var(--bg-color); color: var(--text-main);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .status-msg { text-align: center; padding: 40px 20px; color: var(--text-sub); }
        .fading { opacity: 0.5; pointer-events: none; }
        #empty-state { text-align: center; padding: 60px 20px; color: var(--text-sub); display: flex; flex-direction: column; align-items: center; }
        #empty-state .big-icon { font-size: 4rem; margin-bottom: 20px; opacity: 0.3; }

        /* --- Â∫ïÈÉ®Êñ∞Â¢ûÂçÄÂüü --- */
        #add-card-section {
            padding: 20px 0 40px; display: none; flex-direction: column; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
        .add-circle-btn {
            width: 56px; height: 56px; border-radius: 50%;
            background: var(--card-bg); color: var(--accent);
            font-size: 2rem; border: none; cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        .add-circle-btn:active { transform: scale(0.9); }
        
        #add-search-wrapper {
            display: none; width: 100%; gap: 8px; animation: slideUp 0.2s ease-out;
            background: var(--bg-color); padding: 5px; border-radius: 12px;
        }
        #add-search-wrapper.active { display: flex; }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- ÂÅ¥ÈÇäÊ¨Ñ Sidebar --- */
        .sidebar-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; opacity: 0; visibility: hidden;
            transition: all 0.3s; backdrop-filter: blur(2px);
        }
        .sidebar-overlay.active { opacity: 1; visibility: visible; }

        .sidebar {
            position: fixed; top: 0; left: -100%; width: 85%; max-width: 320px; height: 100%;
            background: var(--card-bg); z-index: 1001; transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column; box-shadow: 2px 0 12px rgba(0,0,0,0.1);
        }
        .sidebar.active { left: 0; }

        .sidebar-header {
            padding: 20px 16px; border-bottom: 1px solid var(--separator);
            display: flex; justify-content: space-between; align-items: center;
        }
        .sidebar-title { font-size: 1.2rem; font-weight: 700; color: var(--text-main); }
        
        .sidebar-content { flex: 1; overflow-y: auto; padding: 10px 0; }

        .sidebar-settings {
            padding: 15px 16px;
            border-bottom: 1px solid var(--separator);
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.02);
        }
        .setting-label { font-size: 1rem; color: var(--text-main); font-weight: 600; }
        
        .ios-switch { position: relative; display: inline-block; width: 51px; height: 31px; }
        .ios-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #E9E9EA; transition: .4s; border-radius: 34px;
        }
        .slider:before {
            position: absolute; content: ""; height: 27px; width: 27px;
            left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input:checked + .slider { background-color: #34C759; }
        input:checked + .slider:before { transform: translateX(20px); }
        body.dark-mode .slider { background-color: #39393D; }

        .saved-item {
            padding: 12px 16px; border-bottom: 1px solid var(--separator);
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; background: var(--card-bg); transition: background 0.2s;
            position: relative;
        }
        .saved-item:active { background: rgba(0,0,0,0.05); }
        .saved-item.dragging { opacity: 0.5; background: #e0e0e0; }

        .saved-drag-handle {
            color: var(--text-sub); margin-right: 12px; font-size: 1.1rem; cursor: grab;
            display: none; 
        }
        .delete-btn {
            padding: 8px; color: #FF3B30; opacity: 0.8; transition: opacity 0.2s; z-index: 2;
            display: none; 
        }

        .sidebar-content.editing .saved-drag-handle { display: block; }
        .sidebar-content.editing .delete-btn { display: block; }
        .sidebar-content.editing .saved-item { padding-left: 10px; } 
        .sidebar-content.editing .saved-info { pointer-events: auto; }

        .saved-info { flex: 1; pointer-events: none; }
        .saved-name { font-size: 1rem; font-weight: 600; color: var(--text-main); display: flex; align-items: center; gap: 6px;}
        .saved-detail { font-size: 0.8rem; color: var(--text-sub); margin-top: 2px; }
        
        .default-badge {
            font-size: 0.65rem; color: white; background: #34C759; padding: 2px 6px;
            border-radius: 4px; font-weight: 700; text-transform: uppercase;
        }

        .sidebar-footer {
            padding: 16px; border-top: 1px solid var(--separator);
            display: flex; gap: 10px;
        }
        
        .save-all-btn {
            flex: 1; padding: 12px; background: var(--accent); color: white;
            border: none; border-radius: 12px; font-weight: 600; font-size: 1rem; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .save-all-btn:active { opacity: 0.9; }

        .edit-mode-btn {
            width: 48px; height: 48px; flex-shrink: 0;
            background: #F2F2F7; color: var(--text-main);
            border: none; border-radius: 12px; font-size: 1.2rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        body.dark-mode .edit-mode-btn { background: #2C2C2E; }
        .edit-mode-btn.active { background: var(--kmb-red); color: white; }

    </style>
</head>
<body>

<div class="sidebar-overlay" id="overlay" onclick="toggleSidebar(false)"></div>
<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <span class="sidebar-title">Â∑≤ÂÑ≤Â≠òÈ†ÖÁõÆ</span>
        <span onclick="toggleSidebar(false)" style="cursor:pointer; padding:5px; font-size:1.2rem;">‚úï</span>
    </div>
    
    <div class="sidebar-settings">
        <span class="setting-label">ÈªëÊöóÊ®°Âºè</span>
        <label class="ios-switch">
            <input type="checkbox" id="dm-toggle" onchange="toggleDarkMode()">
            <span class="slider"></span>
        </label>
    </div>

    <div class="sidebar-content" id="saved-list-container"></div>

    <div class="sidebar-footer">
        <button class="save-all-btn" onclick="saveCurrentAsGroup()">Ôºã ÂÑ≤Â≠òÁï∂ÂâçÁâàÈù¢</button>
        <button class="edit-mode-btn" id="edit-btn" onclick="toggleEditMode()">‚úé</button>
    </div>
</div>

<div class="container">
    <div class="search-area">
        <div class="menu-btn" onclick="toggleSidebar(true)">‚ò∞</div>
        <div class="search-wrapper">
            <input type="text" id="route-input" class="search-input" 
                   placeholder="Ëº∏ÂÖ•Ë∑ØÁ∑ö" value="" 
                   autocomplete="off"
                   oninput="handleInput(this, 'suggestions', 'clear-search')" 
                   onfocus="handleInput(this, 'suggestions', 'clear-search')"
                   onkeypress="if(event.key==='Enter') searchTopRoute()">
            
            <div id="clear-search" class="clear-input-btn" onclick="clearSearch('route-input')">‚úï</div>
            <div id="suggestions" class="suggestions-list"></div>
        </div>
        
        <button id="search-btn" class="search-btn" onclick="searchTopRoute()">Êü•Ë©¢</button>
    </div>

    <div class="content-scroll">
        <div id="cards-container">
            <div id="empty-state">
                <div class="big-icon">üöç</div>
                <div>Ë´ãËº∏ÂÖ•Ë∑ØÁ∑öËôüÁ¢ºÈñãÂßãÊü•Ë©¢</div>
            </div>
        </div>

        <!-- Â∫ïÈÉ®Êñ∞Â¢ûÊåâÈàïÂçÄÂüü -->
        <div id="add-card-section">
            <button id="show-add-btn" class="add-circle-btn" onclick="toggleAddSearch(true)">Ôºã</button>
            <div id="add-search-wrapper">
                <div class="search-wrapper">
                    <input type="text" id="add-route-input" class="search-input" 
                           placeholder="Ëº∏ÂÖ•Ë∑ØÁ∑ö" value="" autocomplete="off"
                           oninput="handleInput(this, 'add-suggestions', 'add-clear-search')" 
                           onfocus="handleInput(this, 'add-suggestions', 'add-clear-search')"
                           onkeypress="if(event.key==='Enter') addRoute()">
                    
                    <div id="add-clear-search" class="clear-input-btn" onclick="clearSearch('add-route-input')">‚úï</div>
                    <div id="add-suggestions" class="suggestions-list"></div>
                </div>
                <button class="search-btn" onclick="addRoute()">Êñ∞Â¢û</button>
                <button class="search-btn" style="background:var(--text-sub)" onclick="toggleAddSearch(false)">‚úï</button>
            </div>
        </div>
    </div>
        
    <div style="text-align:center; font-size:0.7rem; color:var(--text-sub); margin-top:10px; padding-bottom: 20px;">
        Ë≥áÊñô‰æÜÊ∫êÔºöDATA.GOV.HK<br>Designed by Anson Lam
    </div>
</div>

<script>
    let stopCache = {}; // Generic stop cache for both KMB and CTB
    let allRoutesDB = []; 
    let validRouteSet = new Set();
    window.cardRegistry = {};
    let cardCounter = 0;
    let isEditMode = false;

    // API Constants
    const KMB_API_BASE = 'https://data.etabus.gov.hk/v1/transport/kmb';
    const CTB_API_BASE = 'https://rt.data.gov.hk/v2/transport/citybus';

    document.addEventListener('DOMContentLoaded', () => {
        initDarkMode();
        preloadAllRoutes(); 
        StorageManager.loadAll(); 
        
        const savedList = StorageManager.getList();
        if (savedList.length > 0) {
            loadSavedItem(savedList[0].id);
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-wrapper')) {
                document.querySelectorAll('.suggestions-list').forEach(el => el.classList.remove('show'));
            }
        });

        const container = document.getElementById('cards-container');
        container.addEventListener('dragover', e => {
            e.preventDefault(); 
            if (!document.querySelector('.card.dragging')) return;
            const afterElement = getDragAfterElement(container, e.clientY, '.card');
            const draggable = document.querySelector('.card.dragging');
            if (draggable) {
                if (afterElement == null) container.appendChild(draggable);
                else container.insertBefore(draggable, afterElement);
            }
        });

        const sidebarList = document.getElementById('saved-list-container');
        sidebarList.addEventListener('dragover', e => {
            e.preventDefault();
            if (!isEditMode) return;
            if (!document.querySelector('.saved-item.dragging')) return;
            const afterElement = getDragAfterElement(sidebarList, e.clientY, '.saved-item');
            const draggable = document.querySelector('.saved-item.dragging');
            if (draggable) {
                if (afterElement == null) sidebarList.appendChild(draggable);
                else sidebarList.insertBefore(draggable, afterElement);
            }
        });
    });

    const StorageManager = {
        key: 'kmb_saved_list',
        tempList: null, 
        
        getList: () => {
            if (isEditMode && StorageManager.tempList !== null) return StorageManager.tempList;
            return JSON.parse(localStorage.getItem(StorageManager.key) || '[]');
        },

        saveItem: (name, cardsData) => {
            let list = JSON.parse(localStorage.getItem(StorageManager.key) || '[]');
            list.push({ id: Date.now(), name: name, data: cardsData });
            localStorage.setItem(StorageManager.key, JSON.stringify(list));
            if (isEditMode) StorageManager.tempList = list;
            StorageManager.renderList();
        },

        deleteItem: (id) => {
            if (isEditMode) {
                StorageManager.tempList = StorageManager.tempList.filter(item => item.id !== id);
            } else {
                let list = StorageManager.getList();
                list = list.filter(item => item.id !== id);
                localStorage.setItem(StorageManager.key, JSON.stringify(list));
            }
            StorageManager.renderList();
        },
        
        renameItem: (id) => {
            if (!isEditMode) return;
            const item = StorageManager.tempList.find(x => x.id === id);
            if (!item) return;
            const newName = prompt("Ë´ãËº∏ÂÖ•Êñ∞ÂêçÁ®±:", item.name);
            if (newName && newName.trim() !== "") {
                item.name = newName.trim();
                StorageManager.renderList();
            }
        },

        updateOrderFromDOM: () => {
            if (!isEditMode) return;
            const container = document.getElementById('saved-list-container');
            const items = container.querySelectorAll('.saved-item');
            const oldList = StorageManager.tempList;
            const newList = [];
            items.forEach(el => {
                const id = parseInt(el.getAttribute('data-id'));
                const data = oldList.find(x => x.id === id);
                if (data) newList.push(data);
            });
            StorageManager.tempList = newList;
            StorageManager.renderList(); 
        },

        commitChanges: () => {
            if (StorageManager.tempList !== null) {
                localStorage.setItem(StorageManager.key, JSON.stringify(StorageManager.tempList));
                StorageManager.tempList = null;
            }
        },

        discardChanges: () => { StorageManager.tempList = null; },
        initTemp: () => { StorageManager.tempList = JSON.parse(localStorage.getItem(StorageManager.key) || '[]'); },
        loadAll: () => { StorageManager.renderList(); },

        renderList: () => {
            const list = StorageManager.getList();
            const container = document.getElementById('saved-list-container');
            
            if (list.length === 0) {
                container.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-sub);">Êö´ÁÑ°ÂÑ≤Â≠òÈ†ÖÁõÆ</div>';
                return;
            }

            container.innerHTML = list.map((item, index) => {
                const isDefault = index === 0;
                let desc = "";
                if (item.data.length > 1) {
                    desc = `${item.data.length} ÂÄãË∑ØÁ∑öÁµÑÂêà`;
                } else {
                    const d = item.data[0];
                    const co = d.co || 'KMB';
                    if (d.destName) desc = `[${co}] ${d.route} ÂæÄ ${d.destName}`;
                    else desc = `[${co}] ${d.route} ${d.dir==='outbound'?'ÂéªÁ®ã':'ÂõûÁ®ã'}`;
                }

                return `
                    <div class="saved-item" draggable="${isEditMode}" data-id="${item.id}" onclick="onSavedItemClick(${item.id})">
                        <div class="saved-drag-handle">‚â°</div>
                        <div class="saved-info">
                            <div class="saved-name">
                                ${item.name}
                                ${isDefault ? '<span class="default-badge">È†êË®≠</span>' : ''}
                            </div>
                            <div class="saved-detail">${desc}</div>
                        </div>
                        <div class="delete-btn" onclick="deleteSaved(event, ${item.id})">üóë</div>
                    </div>
                `;
            }).join('');

            if (isEditMode) container.classList.add('editing');
            else container.classList.remove('editing');

            StorageManager.bindDragEvents();
        },

        bindDragEvents: () => {
            const items = document.querySelectorAll('.saved-item');
            items.forEach(item => {
                item.addEventListener('dragstart', () => item.classList.add('dragging'));
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    if(isEditMode) StorageManager.updateOrderFromDOM(); 
                });
                
                const handle = item.querySelector('.saved-drag-handle');
                handle.addEventListener('touchstart', (e) => { item.classList.add('dragging'); }, {passive: true});
                handle.addEventListener('touchend', () => {
                     item.classList.remove('dragging');
                     if(isEditMode) StorageManager.updateOrderFromDOM();
                });
                handle.addEventListener('touchmove', (e) => {
                    const container = document.getElementById('saved-list-container');
                    const touchLocation = e.targetTouches[0];
                    const afterElement = getDragAfterElement(container, touchLocation.clientY, '.saved-item');
                    const draggable = document.querySelector('.saved-item.dragging');
                    if (draggable) {
                        if (afterElement == null) container.appendChild(draggable);
                        else container.insertBefore(draggable, afterElement);
                    }
                    e.preventDefault();
                }, {passive: false});
            });
        }
    };

    function toggleSidebar(show) {
        const sb = document.getElementById('sidebar');
        const ov = document.getElementById('overlay');
        if (show) { sb.classList.add('active'); ov.classList.add('active'); } 
        else { 
            if (isEditMode) {
                isEditMode = false;
                StorageManager.discardChanges();
                const btn = document.getElementById('edit-btn');
                btn.innerHTML = '‚úé'; btn.classList.remove('active');
                StorageManager.renderList();
            }
            sb.classList.remove('active'); ov.classList.remove('active'); 
        }
    }

    function toggleEditMode() {
        isEditMode = !isEditMode;
        const btn = document.getElementById('edit-btn');
        if (isEditMode) {
            StorageManager.initTemp();
            btn.innerHTML = 'üíæ'; btn.classList.add('active');
        } else {
            StorageManager.commitChanges();
            btn.innerHTML = '‚úé'; btn.classList.remove('active');
        }
        StorageManager.renderList();
    }

    function onSavedItemClick(id) {
        if (isEditMode) StorageManager.renameItem(id);
        else loadSavedItem(id);
    }

    function saveCurrentAsGroup() {
        const cards = document.querySelectorAll('.card');
        if (cards.length === 0) { alert('ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïÂç°ÁâáÂèØÂÑ≤Â≠ò'); return; }
        
        let defaultName = "";
        if (cards.length > 0) {
            const firstCard = window.cardRegistry[cards[0].id];
            defaultName = `${firstCard.company} ${firstCard.route}`;
            if (firstCard.currentDestName) defaultName += ` ÂæÄ ${firstCard.currentDestName}`;
        }
        if (cards.length > 1) defaultName = 'ÊàëÁöÑÈÄöÂã§ÁµÑÂêà';

        const name = prompt('Ë´ãËº∏ÂÖ•ÂêçÁ®±Ôºö', defaultName);
        if (!name) return;

        const data = [];
        cards.forEach(card => {
            const obj = window.cardRegistry[card.id];
            if (obj) {
                data.push({
                    route: obj.route,
                    dir: obj.dir,
                    co: obj.company,
                    destName: obj.currentDestName, 
                    filteredSeq: obj.filteredSeq,
                    markedSeq: obj.markedSeq
                });
            }
        });
        StorageManager.saveItem(name, data);
    }

    function loadSavedItem(id) {
        const list = StorageManager.getList();
        const item = list.find(x => x.id === id);
        if (!item) return;
        clearAllCards(false);
        item.data.forEach(d => createCard(d.route, d.co || 'KMB', d));
        toggleSidebar(false);
    }

    function deleteSaved(e, id) {
        e.stopPropagation();
        if(confirm('Á¢∫ÂÆöË¶ÅÂà™Èô§ÂóéÔºü')) StorageManager.deleteItem(id);
    }

    function clearAllCards(showEmpty = true) {
        const container = document.getElementById('cards-container');
        container.innerHTML = '';
        window.cardRegistry = {};
        if (showEmpty) {
            const emptyState = document.createElement('div');
            emptyState.id = 'empty-state';
            emptyState.innerHTML = '<div class="big-icon">üöç</div><div>Ë´ãËº∏ÂÖ•Ë∑ØÁ∑öËôüÁ¢ºÈñãÂßãÊü•Ë©¢</div>';
            container.appendChild(emptyState);
        }
        
        // Èö±ËóèÂ∫ïÈÉ®Êñ∞Â¢ûÊåâÈàï
        document.getElementById('add-card-section').style.display = 'none';
    }

    // --- Search & Input Logic ---
    function toggleAddSearch(show) {
        const btn = document.getElementById('show-add-btn');
        const wrapper = document.getElementById('add-search-wrapper');
        const input = document.getElementById('add-route-input');
        if (show) {
            btn.style.display = 'none';
            wrapper.classList.add('active');
            input.focus();
        } else {
            btn.style.display = 'flex';
            wrapper.classList.remove('active');
        }
    }

    function handleInput(inputEl, suggestionId, clearBtnId) {
        const val = inputEl.value.trim().toUpperCase();
        const clearBtn = document.getElementById(clearBtnId);
        
        clearBtn.style.display = val.length > 0 ? 'flex' : 'none';

        if (!val || allRoutesDB.length === 0) { 
            document.getElementById(suggestionId).classList.remove('show'); 
            return; 
        }

        const matches = allRoutesDB.filter(r => r.route.startsWith(val)).slice(0, 50); 
        const list = document.getElementById(suggestionId);
        
        if (matches.length === 0) {
            list.classList.remove('show');
            return;
        }

        list.innerHTML = matches.map(r => `
            <div class="suggestion-item" onmousedown="selectSuggestion('${r.route}', '${r.co}', '${inputEl.id}', '${suggestionId}', '${clearBtnId}')">
                <div class="sug-left">
                    <span class="co-badge ${r.co === 'KMB' ? 'badge-kmb' : 'badge-ctb'}">${r.co === 'KMB' ? 'KMB' : 'ÂüéÂ∑¥'}</span>
                    <span class="sug-route">${r.route}</span>
                </div>
                <span class="sug-desc">${r.orig} ‚áÑ ${r.dest}</span>
            </div>
        `).join('');
        list.classList.add('show');
    }

    function clearSearch(inputId) {
        const input = document.getElementById(inputId);
        input.value = '';
        const clearBtnId = inputId === 'route-input' ? 'clear-search' : 'add-clear-search';
        document.getElementById(clearBtnId).style.display = 'none';
        input.focus();
    }

    function selectSuggestion(route, co, inputId, suggestionId, clearBtnId) {
        const input = document.getElementById(inputId);
        input.value = route;
        input.setAttribute('data-selected-co', co); // Store selected company
        document.getElementById(suggestionId).classList.remove('show');
        
        if (inputId === 'route-input') searchTopRoute();
        else addRoute();
    }

    // Shake animation for error
    function triggerShake(inputId) {
        const input = document.getElementById(inputId);
        input.classList.add('shake');
        setTimeout(() => input.classList.remove('shake'), 400);
        input.focus();
    }

    // Top Search (Clear All + Create)
    function searchTopRoute() {
        const inputEl = document.getElementById('route-input');
        const input = inputEl.value.trim().toUpperCase();
        if (!input) return;
        
        let co = inputEl.getAttribute('data-selected-co');
        
        // Check if route exists in DB
        const matches = allRoutesDB.filter(r => r.route === input);
        if (matches.length === 0) {
             triggerShake('route-input'); return;
        }

        // If not selected from list (typed and enter), pick first or all? 
        // Logic: if company not set, and multiple matches, maybe default to KMB or add both?
        // Let's add the first match found if user typed manually.
        if (!co) {
            co = matches[0].co;
        }

        inputEl.blur(); 
        inputEl.removeAttribute('data-selected-co');
        document.getElementById('suggestions').classList.remove('show'); 
        
        clearAllCards(false);
        createCard(input, co);
    }

    // Bottom Add (Accumulate)
    function addRoute() {
        const inputEl = document.getElementById('add-route-input');
        const input = inputEl.value.trim().toUpperCase();
        if (!input) return;

        let co = inputEl.getAttribute('data-selected-co');
        const matches = allRoutesDB.filter(r => r.route === input);
        if (matches.length === 0) {
             triggerShake('add-route-input'); return;
        }
        if (!co) co = matches[0].co;
        
        createCard(input, co);
        
        // Reset bottom search
        inputEl.value = '';
        inputEl.removeAttribute('data-selected-co');
        toggleAddSearch(false);
    }
    
    function createCard(route, company = 'KMB', savedState = null) {
        cardCounter++;
        const newCardId = `card-${cardCounter}`;
        const newCard = new BusRouteCard(route, newCardId, savedState, company);
        window.cardRegistry[newCardId] = newCard;
        newCard.init();
        
        // ÊúâÂç°ÁâáÂæåÔºåÈ°ØÁ§∫Â∫ïÈÉ®Êñ∞Â¢ûÊåâÈàï
        document.getElementById('add-card-section').style.display = 'flex';
    }

    class BusRouteCard {
        constructor(route, containerId, savedState = null, company = 'KMB') {
            this.id = containerId; 
            this.route = route;
            this.company = savedState ? (savedState.co || company) : company; // Handle legacy saved items
            this.dir = savedState ? savedState.dir : 'outbound';
            this.markedSeq = savedState ? savedState.markedSeq : null; 
            this.filteredSeq = savedState ? savedState.filteredSeq : null; 
            this.currentDestName = savedState ? savedState.destName : ''; 
            this.lastRows = []; 
            this.element = null; 
            this.timer = null;
        }

        init() {
            const emptyState = document.getElementById('empty-state');
            if (emptyState) emptyState.remove();

            const div = document.createElement('div');
            div.className = 'card';
            if (this.company === 'CTB') div.classList.add('ctb-card');
            div.id = this.id;
            div.setAttribute('draggable', 'true');
            
            const coName = this.company === 'KMB' ? '‰πùÂ∑¥' : 'ÂüéÂ∑¥';

            div.innerHTML = `
                <div class="card-header">
                    <div class="drag-handle">‚â°</div>
                    <div class="close-card-btn" onclick="window.cardRegistry['${this.id}'].destroy()">‚úï</div>
                    
                    <div class="header-top">
                        <div style="display:flex; align-items:center;">
                            <span class="icon">üöå</span>
                            <span class="card-title">${coName} ${this.route}</span>
                        </div>
                        <div style="font-size:0.8rem; opacity:0.8" class="update-time"></div>
                    </div>

                    <div class="direction-switch" style="display:flex;">
                        <span class="dir-opt btn-out active" onclick="window.cardRegistry['${this.id}'].switchDirection('outbound')">ÂæÄ ËºâÂÖ•‰∏≠...</span>
                        <span class="dir-opt btn-in" onclick="window.cardRegistry['${this.id}'].switchDirection('inbound')">ÂæÄ ËºâÂÖ•‰∏≠...</span>
                    </div>
                </div>

                <div class="card-content">
                    <div class="status-msg">Ê≠£Âú®ÂàÜÊûêË∑ØÁ∑öË≥áÊñô...</div>
                </div>
            `;
            
            const container = document.getElementById('cards-container');
            container.appendChild(div);
            this.element = div;
            
            setTimeout(() => { div.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
            
            this.initDragEvents(div);
            this.updateDirectionUI(); 

            this.fetchRouteBoundaries().then(() => {
                this.fetchBusData();
                this.timer = setInterval(() => this.fetchBusData(), 30000);
            });
        }

        updateDirectionUI() {
            const btnOut = this.element.querySelector('.btn-out');
            const btnIn = this.element.querySelector('.btn-in');
            btnOut.classList.toggle('active', this.dir === 'outbound');
            btnIn.classList.toggle('active', this.dir === 'inbound');
        }

        initDragEvents(cardEl) {
            const handle = cardEl.querySelector('.drag-handle');
            const container = document.getElementById('cards-container');
            cardEl.addEventListener('dragstart', () => { cardEl.classList.add('dragging'); });
            cardEl.addEventListener('dragend', () => { cardEl.classList.remove('dragging'); });
            handle.addEventListener('touchstart', (e) => { cardEl.classList.add('dragging'); }, { passive: true });
            handle.addEventListener('touchend', () => { cardEl.classList.remove('dragging'); });
            handle.addEventListener('touchmove', (e) => {
                const touchLocation = e.targetTouches[0];
                const afterElement = getDragAfterElement(container, touchLocation.clientY, '.card');
                if (afterElement == null) container.appendChild(cardEl);
                else container.insertBefore(cardEl, afterElement);
                e.preventDefault();
            }, { passive: false });
        }

        destroy() {
            if (this.element) {
                if (this.timer) clearInterval(this.timer);
                this.element.style.transition = 'opacity 0.3s, transform 0.3s';
                this.element.style.opacity = '0';
                this.element.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    this.element.remove();
                    delete window.cardRegistry[this.id];
                    if (Object.keys(window.cardRegistry).length === 0) {
                        clearAllCards(true); // Ëá™ÂãïÊÅ¢Âæ© Empty State ‰∏¶Èö±Ëóè + ÊåâÈàï
                    }
                }, 300);
            }
        }

        async fetchRouteBoundaries() {
            let outStops = [], inStops = [];
            
            if (this.company === 'KMB') {
                [outStops, inStops] = await Promise.all([
                    getKmbRouteStops(this.route, 'outbound'), 
                    getKmbRouteStops(this.route, 'inbound')
                ]);
            } else {
                [outStops, inStops] = await Promise.all([
                    getCtbRouteStops(this.route, 'outbound'),
                    getCtbRouteStops(this.route, 'inbound')
                ]);
            }
            
            // Resolve last stop names for buttons
            let outName = 'ÂéªÁ®ã';
            let inName = 'ÂõûÁ®ã';
            const btnOut = this.element.querySelector('.btn-out');
            const btnIn = this.element.querySelector('.btn-in');

            if (outStops && outStops.length > 0) {
                const lastStopId = outStops[outStops.length - 1].stop;
                const name = await getStopName(lastStopId, this.company);
                btnOut.innerText = `ÂæÄ ${name}`;
                outName = name;
            } else { btnOut.innerText = 'ÂéªÁ®ã (ÁÑ°Ë≥áÊñô)'; }

            if (inStops && inStops.length > 0) {
                const lastStopId = inStops[inStops.length - 1].stop;
                const name = await getStopName(lastStopId, this.company);
                btnIn.innerText = `ÂæÄ ${name}`;
                btnIn.style.display = 'block'; 
                inName = name;
            } else {
                btnIn.style.display = 'none'; 
                if (outStops.length > 0) btnOut.innerText += ' (Âæ™Áí∞Á∑ö)';
            }
            this.destMap = { outbound: outName, inbound: inName };
            this.currentDestName = this.destMap[this.dir];
            
            // Cache current stops for ETA usage
            this.currentStops = this.dir === 'outbound' ? outStops : inStops;
            
            // Update UI immediately if possible? No wait for ETA.
            if (!this.currentStops || this.currentStops.length === 0) {
                 const listEl = this.element.querySelector('.card-content');
                 listEl.innerHTML = '<div class="status-msg">Ê≠§ÊñπÂêëÁÑ°ËªäÁ´ôË≥áÊñô</div>';
            }
        }

        switchDirection(dir) {
            if (this.dir === dir) return;
            this.dir = dir;
            this.markedSeq = null; this.filteredSeq = null; 
            if(this.destMap) this.currentDestName = this.destMap[dir];
            this.updateDirectionUI();
            
            // Re-fetch stops for new direction
            this.fetchRouteBoundaries().then(() => {
                this.fetchBusData();
            });
        }

        async fetchBusData() {
            const listEl = this.element.querySelector('.card-content');
            const timeEl = this.element.querySelector('.update-time');
            if(listEl.innerHTML.includes('Êö´ÁÑ°Ë≥áÊñô') || listEl.innerHTML.includes('Ê≠£Âú®ÂàÜÊûê')) {
                listEl.classList.add('fading');
            }
            timeEl.innerText = 'Êõ¥Êñ∞‰∏≠...';
            
            try {
                if (!this.currentStops || this.currentStops.length === 0) {
                    // Try fetch boundaries if not set
                     await this.fetchRouteBoundaries();
                     if (!this.currentStops || this.currentStops.length === 0) {
                         listEl.innerHTML = '<div class="status-msg">Ê≠§ÊñπÂêëÁÑ°ËªäÁ´ôË≥áÊñô</div>';
                         listEl.classList.remove('fading');
                         return;
                     }
                }
                
                let rows = [];

                if (this.company === 'KMB') {
                    // KMB Bulk ETA
                    const etaRes = await fetch(`${KMB_API_BASE}/route-eta/${this.route}/1`);
                    const etaData = await etaRes.json();
                    const allEtas = etaData.data || [];
                    const apiDir = this.dir === 'outbound' ? 'O' : 'I';
                    
                    rows = await Promise.all(this.currentStops.map(async (stopInfo) => {
                        const name = await getStopName(stopInfo.stop, 'KMB');
                        const stopEtas = allEtas.filter(e => 
                            e.seq === parseInt(stopInfo.seq) && e.dir === apiDir && e.eta != null
                        ).sort((a, b) => new Date(a.eta) - new Date(b.eta));
                        return { seq: parseInt(stopInfo.seq), name: name, etas: stopEtas };
                    }));

                } else {
                    // CTB Individual ETA per stop (Promise.all)
                    // CTB Route-Stop data has stops. Fetch name first for all to ensure UI looks good
                    // But names are fetched in getStopName with cache.
                    
                    const promises = this.currentStops.map(async (stopInfo) => {
                         const name = await getStopName(stopInfo.stop, 'CTB');
                         
                         // Fetch ETA
                         let stopEtas = [];
                         try {
                             const url = `${CTB_API_BASE}/eta/CTB/${stopInfo.stop}/${this.route}`;
                             const res = await fetch(url);
                             const json = await res.json();
                             if (json.data) {
                                 // data contains all etas for this stop-route. 
                                 // Need to filter direction. CTB returns dir "I" or "O".
                                 // this.dir is 'outbound' or 'inbound'
                                 const targetDir = this.dir === 'outbound' ? 'O' : 'I';
                                 stopEtas = json.data.filter(e => e.dir === targetDir && e.eta).sort((a, b) => new Date(a.eta) - new Date(b.eta));
                             }
                         } catch (e) { console.warn('CTB ETA fetch fail', stopInfo.stop); }
                         
                         return { seq: parseInt(stopInfo.seq), name: name, etas: stopEtas };
                    });
                    
                    rows = await Promise.all(promises);
                }

                this.lastRows = rows; 
                this.renderList(this.lastRows); 
                this.applyVisualState();   
                timeEl.innerText = 'Êõ¥Êñ∞Êñº ' + new Date().toLocaleTimeString('zh-HK', {hour:'2-digit', minute:'2-digit'});
            } catch (e) {
                console.error(e);
                listEl.innerHTML = '<div class="status-msg error">Ë≥áÊñôËºâÂÖ•Â§±Êïó</div>';
            } finally {
                listEl.classList.remove('fading');
            }
        }

        renderList(rows) {
            const listEl = this.element.querySelector('.card-content');
            if (rows.length === 0) {
                listEl.innerHTML = '<div class="status-msg">Êö´ÁÑ°Ë≥áÊñô</div>';
                return;
            }
            const html = rows.sort((a, b) => a.seq - b.seq).map(row => {
                let timeHtml = '';
                if (row.etas.length === 0) {
                    timeHtml = '<span style="color:var(--text-sub); font-size:0.85rem;">Êö´ÁÑ°Áè≠Ê¨°</span>';
                } else {
                    timeHtml = row.etas.slice(0, 3).map(e => {
                        const mins = getMins(e.eta);
                        const d = new Date(e.eta);
                        const timeStr = ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
                        const isUrgent = mins === 'Âç≥Â∞á' || mins === '0ÂàÜ' || mins === '1ÂàÜ';
                        return `<span class="eta-minutes ${isUrgent ? 'urgent' : ''}" data-min="${mins}" data-time="${timeStr}" style="margin-left:4px;">${mins}</span>`;
                    }).join('');
                }
                return `
                <div class="schedule-item" data-seq="${row.seq}" onclick="window.cardRegistry['${this.id}'].toggleEtas(this)">
                    <div class="stop-info">
                        <span class="dest-seq" onclick="window.cardRegistry['${this.id}'].togglePin(event, ${row.seq})">${row.seq}</span>
                        <span class="dest-name">${row.name}</span>
                    </div>
                    <div style="text-align:right; min-width:120px; flex-shrink:0;">
                        ${timeHtml}
                    </div>
                </div>`;
            }).join('');
            listEl.innerHTML = html;
        }

        togglePin(e, seq) {
            e.stopPropagation();
            if (this.filteredSeq === seq) {
                this.filteredSeq = null; this.markedSeq = null;
            } else if (this.markedSeq === seq) {
                this.filteredSeq = seq;
            } else {
                this.markedSeq = seq; this.filteredSeq = null;
            }
            this.applyVisualState();
        }

        applyVisualState() {
            const items = this.element.querySelectorAll('.schedule-item');
            items.forEach(item => {
                const seq = parseInt(item.getAttribute('data-seq'));
                const seqSpan = item.querySelector('.dest-seq');
                if (this.filteredSeq !== null && this.filteredSeq !== seq) item.classList.add('hidden-row');
                else item.classList.remove('hidden-row');
                
                if (this.filteredSeq !== null && this.filteredSeq === seq) item.classList.add('no-border');
                else item.classList.remove('no-border');

                if (this.markedSeq === seq) {
                    seqSpan.innerText = 'üìå';
                    seqSpan.style.opacity = '1';
                } else {
                    seqSpan.innerText = seq;
                    seqSpan.style.opacity = '';
                }
            });
        }

        toggleEtas(row) {
            const spans = row.querySelectorAll('.eta-minutes');
            if(spans.length === 0) return;
            const isShowingTime = row.classList.contains('mode-time');
            if (isShowingTime) {
                row.classList.remove('mode-time');
                spans.forEach(span => { span.innerText = span.getAttribute('data-min'); span.classList.remove('show-real-time'); });
            } else {
                row.classList.add('mode-time');
                spans.forEach(span => { span.innerText = span.getAttribute('data-time'); span.classList.add('show-real-time'); });
            }
        }
    }

    function getDragAfterElement(container, y, selector) {
        const draggableElements = [...container.querySelectorAll(`${selector}:not(.dragging)`)];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
            else return closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    async function preloadAllRoutes() {
        try {
            // Fetch both KMB and CTB routes
            const [kmbRes, ctbRes] = await Promise.all([
                fetch(`${KMB_API_BASE}/route/`).catch(e => ({ json: () => ({ data: [] }) })),
                fetch(`${CTB_API_BASE}/route/CTB`).catch(e => ({ json: () => ({ data: [] }) }))
            ]);
            
            const kmbJson = await kmbRes.json();
            const ctbJson = await ctbRes.json();
            
            const routeMap = [];
            
            if (kmbJson.data) {
                kmbJson.data.forEach(r => {
                    routeMap.push({ route: r.route, orig: r.orig_tc, dest: r.dest_tc, co: 'KMB' });
                    validRouteSet.add(r.route);
                });
            }
            
            if (ctbJson.data) {
                ctbJson.data.forEach(r => {
                    routeMap.push({ route: r.route, orig: r.orig_tc, dest: r.dest_tc, co: 'CTB' });
                    validRouteSet.add(r.route);
                });
            }

            // Sort logic: Numeric part first, then alpha, then company
            allRoutesDB = routeMap.sort((a, b) => {
                const rA = a.route;
                const rB = b.route;
                const numA = parseInt(rA.replace(/\D/g, '')) || 0;
                const numB = parseInt(rB.replace(/\D/g, '')) || 0;
                
                if (numA !== numB) return numA - numB;
                if (rA !== rB) return rA.localeCompare(rB);
                return a.co.localeCompare(b.co);
            });
            
        } catch (e) { console.error('Route Preload Error', e); }
    }

    // --- API Helpers ---

    async function getKmbRouteStops(route, dir) {
        try { 
            const res = await fetch(`${KMB_API_BASE}/route-stop/${route}/${dir}/1`); 
            const data = await res.json(); 
            return data.data; 
        } catch { return []; }
    }

    async function getCtbRouteStops(route, dir) {
        try {
            // CTB uses outbound/inbound in URL for direction usually
            const res = await fetch(`${CTB_API_BASE}/route-stop/CTB/${route}/${dir}`);
            const data = await res.json();
            return data.data; // returns array of { stop, seq, dir, ... }
        } catch { return []; }
    }

    async function getStopName(stopId, company) {
        // Shared cache but values should be unique or keyed
        const key = `${company}_${stopId}`;
        if (stopCache[key]) return stopCache[key];
        
        try {
            let url = '';
            if (company === 'KMB') url = `${KMB_API_BASE}/stop/${stopId}`;
            else url = `${CTB_API_BASE}/stop/${stopId}`;

            const res = await fetch(url);
            const data = await res.json();
            const name = data.data.name_tc;
            stopCache[key] = name;
            return name;
        } catch { return 'Êú™Áü•ËªäÁ´ô'; }
    }

    const getMins = (iso) => { if (!iso) return '--'; const diff = Math.floor((new Date(iso) - new Date()) / 60000); return diff <= 0 ? 'Âç≥Â∞á' : `${diff}ÂàÜ`; };

    function toggleDarkMode() {
        const isChecked = document.getElementById('dm-toggle').checked;
        if (isChecked) { document.body.classList.add('dark-mode'); localStorage.setItem('darkMode', 'enabled'); }
        else { document.body.classList.remove('dark-mode'); localStorage.setItem('darkMode', 'disabled'); }
    }
    function initDarkMode() {
        const savedMode = localStorage.getItem('darkMode');
        const toggle = document.getElementById('dm-toggle');
        if (savedMode === 'enabled' || (!savedMode && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode'); 
            if(toggle) toggle.checked = true;
        }
    }
</script>
</body>
</html>
